<Chart width=350 height=200>

  <Axis xDomain={[min_year-0.75, higher_year]} xTicks={[xTicks, 'd']}
        yDomain={[lower_accuracy, 1]} yTicks={[5, '%']}
        fontSize="6px" axisOpacity=1>

    {#each data as point, i}
      <Translate position={[point.year, point.accuracy]}>
        <circle cx=0 cy=0 r=3 fill={point.color ? point.color : tab.blue}
                style="cursor: pointer;"
                on:mouseenter={(event) => {activate(event, point)}}
                on:mouseleave={(event) => {activate(event, point, false)}} />

        <MultilineText
          y={(i % 2) == 0 ? "0" : ".5em"}
          style="font-size: 6px" textAnchor="middle"
          down={(i % 2) == 1}
          text={point.label}
          />
      </Translate>
    {/each}

    {#if userStats != null}
      {#each Object.keys(userStats) as mode}
        {#if userStats[mode].total > 0}
          <Translate position={[thisYear, userStats[mode].correct / userStats[mode].total]}>
            <g transform="translate(-4, -4) scale(0.016717865)" fill={tab.orange}>
              <path d="M477.795,184.279c-1.765-5.431-6.458-9.389-12.108-10.209l-147.159-21.384l-65.812-133.35
          			c-2.527-5.12-7.741-8.361-13.451-8.361s-10.924,3.241-13.451,8.361l-65.812,133.35L12.843,174.07
          			c-5.65,0.82-10.344,4.778-12.108,10.209c-1.765,5.43-0.293,11.391,3.796,15.376l106.484,103.798L85.877,450.018
          			c-0.965,5.627,1.349,11.314,5.968,14.671c4.618,3.354,10.741,3.799,15.797,1.142l131.623-69.199l131.623,69.199
          			c2.195,1.153,4.592,1.723,6.979,1.723c3.11,0,6.205-0.966,8.818-2.864c4.619-3.356,6.933-9.044,5.968-14.671l-25.138-146.565
          			l106.484-103.798C478.088,195.669,479.56,189.708,477.795,184.279z"/>
            </g>
            <MultilineText
              y={mode=="20" ? ".5em" : "0"}
              style="font-size: 6px" textAnchor="middle"
              down={mode=="20"}
              text={`Your score\n(${mode}-way)`}
              />
          </Translate>
        {/if}
      {/each}
    {/if}
  </Axis>
</Chart>

<span class="tag tooltip" bind:this={tooltip}>
</span>

<script>
  import {Chart, Axis, Translate, MultilineText} from './elements'
  import {teaserStats} from './util/store'
  import {tab} from './util/colors'
  import * as d3 from 'd3';

  const thisYear = new Date().getFullYear()

  let tooltip = null

  let data = [
    {
      year: 2011, accuracy: 0.549,
      label: "Generative\nStroke\nModel",
      ref: "#caption_generative_stroke_model"
    },
    {
      year: 2017 + .1, accuracy: .958,
      label: "MAML",
      color: tab.red,
      ref: ""
    },
    {
      year: 2017-0.05, accuracy: .96,
      label: "Prototypical\nNetworks",
      ref: '#caption_prototypical_networks'
    },
    {
      year: 2016, accuracy: .958,
      label: "Matching\nNets",
      ref: "#caption_matching_nets"
    },
    {
      year: 2015, accuracy: .938,
      label: "Siamese Nets",
      ref: "#caption_siames_nets"
    },
    {
      year: 2013, accuracy: .962,
      label: "Hierarchial Bayesian\nProgram Learning",
      ref: "#caption_hierachical_bayesian_program_learning"
    }
  ]

  data.sort((a, b) => a.year - b.year)

  const min_accuracy = 0.5
  const min_year = 2011
  const max_year = 2017

  let lower_accuracy = min_accuracy
  let higher_year = max_year


  let userStats = null

  let xTicks = 5

  teaserStats.subscribe((value) => {
    userStats = value;

    if (userStats != null) {
      lower_accuracy = min_accuracy
      for (let mode in userStats){
        if (userStats[mode].total > 0) {
          let acc = userStats[mode].correct / userStats[mode].total

          lower_accuracy = Math.min(lower_accuracy, acc)
        }
      }

      higher_year = thisYear

      // redraw points
      data = [...data]
      lower_accuracy = lower_accuracy
    } else {
      lower_accuracy = min_accuracy
      higher_year = max_year

      // redraw points
      data = [...data]
      lower_accuracy = lower_accuracy
    }

    xTicks = 1+higher_year-min_year
    if (xTicks >= 10){
      xTicks = Math.floor(xTicks / 2)
    }
  })

  const activate = (event, point, active=true) => {
    if (active) {
      if (point.ref) {
        d3.select(point.ref).attr('class', 'active fewShotMethods-reference');
      }

      tooltip.innerText = (100 * point.accuracy).toFixed(1) + "%"

      d3.select(tooltip)
        .style("top", (event.clientY - 15) + "px")
        .style("left", (event.clientX + 16) + "px")
        .style("opacity", 1)
    } else {
      if (point.ref) {
        d3.select(point.ref).attr('class', 'fewShotMethods-reference')
      }
      //tooltip.innerText = "";
      d3.select(tooltip).style("opacity", 0)
    }
  }


</script>


<style>
  :global(.fewShotMethods-reference) {
    transition: color .2s;
    position: relative;
  }

  .tooltip {
    position: fixed;
    opacity: 0;
    transition: opacity .2s;
  }

  :global(.fewShotMethods-reference.active) {
    color: black;
  }

  :global(.fewShotMethods-reference::before) {
    position: absolute;
    top: 0;
    left: 0;
    content: ' ';
    width: 100%;
    height: 100%;
    opacity: 0;
    background-color: #ff7f0e;
    transition: opacity .2s;
    display: inline-block
  }

  :global(.fewShotMethods-reference.active::before) {
    opacity: 0.4;
  }


</style>
