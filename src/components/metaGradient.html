<div>
  {#each tasks as task, i}
  <input type="radio" bind:group={selected_task} value={i} id={`loss_${i+1}`}>
  <label for={`loss_${i+1}`}>
    {i+1}
  </label>
  {/each}
</div>


<Chart width=600 height=400>
  <Axis>
    {#each tasks as loss, i}
    <ContourPlot lossFunc={loss} logScale={false} opacity={i==selected_task ? 1 : 0} />
    {/each}

    {#each tasks as loss, i}
    <ContourPlot lossFunc={loss} logScale={false} opacity={i==selected_task ? 1 : 0} />
    {/each}

    {#each updates as phi, i}
    <Arrow origin={theta} target={phi} trimStart=0 trimEnd=0.01 stroke="#fff" fill="#fff" stroke-width="2" />
    {/each}

    <VariableHandleWithReference bind:position={theta} value="\theta" offset={[0, -15]} referencePoint={null} />

    {#each updates as phi, i}
    <VariableHandleWithReference bind:position={phi} value={`\\phi_{${i}}`} offset={[0, -15]} referencePoint={theta} />
    {/each}

    {#each algos as alg, i}
    <Arrow origin={theta} target={alg} trimStart=0 trimEnd=0.01 stroke="#fff" fill="#fff" stroke-width="2" />
    {/each}

    {#each algos as alg, i}
    <VariableHandleWithReference bind:position={alg} value={`A_{${i}}`} offset={[0, -15]} referencePoint={theta}/>
    {/each}

  </Axis>
</Chart>



<script>
  import ContourPlot from './contourPlot.html'
  import { Chart, Axis, Arrow, VariableHandleWithReference } from './elements'
  import * as d3 from 'd3';
  import { onMount, getContext } from 'svelte';
  import * as tf from '@tensorflow/tfjs'
  import { Random2DLinearRegressionLossSpace } from './util/LossSpace'

  import { rosenbrock as loss_1 } from './util/loss'
  import { beale as loss_2 } from './util/loss'

  import { Reptile, FirstOrderMAML, VanillaGradientDescent, MAML } from './util/metal-lib'

  // Credit: https://stackoverflow.com/questions/27078285/simple-throttle-in-js
  function throttle(callback, limit) {
    var waiting = false;                      // Initially, we're not waiting
    return function () {                      // We return a throttled function
      if (!waiting) {                       // If we're not waiting
        callback.apply(this, arguments);  // Execute users function
        waiting = true;                   // Prevent future invocations
        setTimeout(function () {          // After a period of time
          waiting = false;              // And allow future invocations
        }, limit);
      }
    }
  }

  let theta = [0.5, .9]
  let means = [[0, 0], [1, 0]]
  let lossSpaces = means.map(mean => new Random2DLinearRegressionLossSpace(mean))

  let selected_task = 0

  let lr = 0.04
  let beta = 0.03
  let eta = 0.3

  let reptile = new Reptile(eta, lr, 5)
  let fomaml = new FirstOrderMAML(beta, lr, 1)
  let vgd = new VanillaGradientDescent(lr, 1)
  let maml = new MAML(beta, lr, 1)

  let algos = [theta, theta, theta]
  let lossGradients = lossSpaces.map(space => space.lossGrad)
  let updates = lossGradients.map(space => theta)

  let metaLoss = x => tf.stack(lossGradients.map((lossGradient, i) => {
    //let thetaVar = new MetaVariable(x)
    let optimalParam = vgd.update(x, lossGradient)
    return lossSpaces[i].loss(optimalParam.clone())
  })).sum(0)
  let tasks = [metaLoss, ...lossSpaces.map(space => space.loss)]

  function updateDirections(t){
   // let thetaVar = new MetaVariable([t])

    updates = lossGradients.map(lossGradient => vgd.update([t], lossGradient).arraySync()[0])
    algos[0] = reptile.update([t], lossGradients).arraySync()[0]
    algos[1] = fomaml.update([t], lossGradients).arraySync()[0]
    algos[2] = maml.update([t], lossGradients).arraySync()[0]
  }

  const updateDirectionsThrottle = throttle(updateDirections, 100)

  $: {    
    updateDirectionsThrottle(theta)
  }

</script>