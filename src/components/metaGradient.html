<!--<div>
  {#each tasks as task, i}
  <input type="radio" bind:group={selected_task} value={i} id={`loss_${i+1}`}>
  <label for={`loss_${i+1}`}>
    {i+1}
  </label>
  {/each}
</div> -->

<!--
<Chart width=600 height=400>
  <Axis>
    {#each tasks as loss, i}
    <ContourPlot lossFunc={loss} logScale={false} opacity={i==selected_task ? 1 : 0} />
    {/each}

    {#each tasks as loss, i}
    <ContourPlot lossFunc={loss} logScale={false} opacity={i==selected_task ? 1 : 0} />
    {/each}

    {#each updates as phi, i}
    <Arrow origin={theta} target={phi} trimStart=0 trimEnd=0.01 stroke-width="2" />
    {/each}

    <VariableHandleWithReference bind:position={theta} value="\theta" offset={[0, -15]} referencePoint={null} />

    {#each updates as phi, i}
    <VariableHandleWithReference bind:position={phi} value={`\\phi_{${i}}`} offset={[0, -15]} referencePoint={theta} />
    {/each}

    {#each algos as alg, i}
    <Arrow origin={theta} target={alg} trimStart=0 trimEnd=0.01 stroke-width="2" />
    {/each}

    {#each algos as alg, i}
    <VariableHandleWithReference bind:position={alg} value={`A_{${i}}`} offset={[0, -15]} referencePoint={theta}/>
    {/each}

  </Axis>
</Chart>
-->

<div class="columns">
  <div class="column">
    <div class="columns is-multiline">
      {#each algs as alg, i}
      <div class="column is-half">
        <div style="text-align: center;">{algNames[i]}</div>
        <Chart width=400 height=400>
          <Axis>
            <ContourPlot lossFunc={tasks[0]} logScale={false} />

            <VariableHandleWithReference bind:position={theta} value="\theta" offset={[0, -15]} referencePoint={null} />

            <Arrow origin={theta} target={alg} trimStart=0 trimEnd=0.01 stroke="#fff" fill="#fff" stroke-width="2" />

            <VariableHandleWithReference bind:position={alg} value={`U(\\theta)`} offset={[0, -15]}
              referencePoint={theta} />

          </Axis>
        </Chart>

      </div>
      {/each}
    </div>
  </div>
  <div class="column is-one-third">
    <CollapsibleCard title="MAML" bind:group={shownSettings}>
      <Slider min="0" max="10" label="Outer Learning Rate" />
      <Slider min="0" max="10" label="Inner Learning Rate" />
    </CollapsibleCard>
    <CollapsibleCard title="FOMAML" bind:group={shownSettings}>
      <Slider min="0" max="10" label="Outer Learning Rate" />
      <Slider min="0" max="10" label="Inner Learning Rate" />
    </CollapsibleCard>
    <CollapsibleCard title="REPTILE" bind:group={shownSettings}>
      <Slider min="0" max="10" label="Interpolation Rate" />
      <Slider min="0" max="10" label="Inner Learning Rate" />
      <Slider min="0" max="10" label="Inner Steps" />
    </CollapsibleCard>
    <CollapsibleCard title="iMAML" bind:group={shownSettings}>
      <Slider min="0" max="10" label="Outer Learning Rate" />
      <Slider min="0" max="10" label="Inner Learning Rate" />
      <Slider min="0" max="10" label="Inner Steps" />
      <Slider min="0" max="10" label="Regularization Coeffiecient" />
    </CollapsibleCard>
  </div>
</div>


<script>
  import ContourPlot from './contourPlot.html'
  import { Slider, Chart, CollapsibleCard, Axis, Arrow, VariableHandleWithReference } from './elements'
  import * as d3 from 'd3';
  import { onMount, getContext } from 'svelte';
  import * as tf from '@tensorflow/tfjs'
  import { Random2DLinearRegressionLossSpace } from './util/LossSpace'

  import { rosenbrock as loss_1 } from './util/loss'
  import { beale as loss_2 } from './util/loss'

  import { Reptile, FirstOrderMAML, VanillaGradientDescent, MAML, iMAML } from './util/metal-lib'

  import throttle from 'lodash/throttle'

  let theta = [0.5, .9]
  let means = [[0, 0], [1, 0]]
  let lossSpaces = means.map(mean => new Random2DLinearRegressionLossSpace(mean))

  let selected_task = 0

  let lr = 0.04
  let beta = 0.03
  let eta = 0.3

  let shownSettings = null

  let reptileOuter = eta,
    reptileInner = lr,
    reptileSteps = 5,
    fomamlOuter = beta,
    fomamlInner = lr,
    fomamlSteps = 1,
    mamlOuter = beta,
    mamlInner = lr,
    mamlSteps = 1,
    imamlOuter = beta,
    imamlInner = lr,
    imamlSteps = 1



  let vgd = new VanillaGradientDescent(lr, 1)

  let algs = [theta, theta, theta, theta]
  let algNames = ['MAML', 'First-Order MAML', 'Reptile', 'iMAML']

  let lossGradients = lossSpaces.map(space => space.lossGrad)

  let metaLoss = x => tf.stack(lossGradients.map((lossGradient, i) => {
    let optimalParam = vgd.update(x, lossGradient)
    return lossSpaces[i].loss(optimalParam.clone())
  })).sum(0)
  let tasks = [metaLoss, ...lossSpaces.map(space => space.loss)]

  function updateDirections(t, _reptileOuter, _reptileInner, _reptileSteps, _fomamlOuter, _fomamlInner, _fomamlSteps,
    _mamlOuter, _mamlInner, _mamlSteps, _imamlOuter, _imamlInner, _imamlSteps) {

    let reptile = new Reptile(_reptileOuter, _reptileInner, _reptileSteps)
    let fomaml = new FirstOrderMAML(_fomamlOuter, _fomamlInner, _fomamlSteps)
    let maml = new MAML(_mamlOuter, _mamlInner, _mamlSteps)
    let imaml = new iMAML(_imamlOuter, _imamlInner, _imamlSteps)


    algs[0] = maml.update([t], lossGradients).arraySync()[0]
    algs[1] = fomaml.update([t], lossGradients).arraySync()[0]
    algs[2] = reptile.update([t], lossGradients).arraySync()[0]
    algs[3] = imaml.update([t], lossGradients).arraySync()[0]
  }

  const updateDirectionsThrottle = throttle(updateDirections, 100)

  $: {
    updateDirectionsThrottle(theta, reptileOuter, reptileInner, reptileSteps, fomamlOuter, fomamlInner, fomamlSteps,
      mamlOuter, mamlInner, mamlSteps, imamlOuter, imamlInner, imamlSteps)
  }

</script>
