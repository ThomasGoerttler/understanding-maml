<div>
  {#each tasks as task, i}
  <input type="radio" bind:group={selected_task} value={i} id={`loss_${i+1}`}>
  <label for={`loss_${i+1}`}>
    {i+1}
  </label>
  {/each}
</div>


<Chart width=600 height=400>
  <Axis>
    {#each tasks as loss, i}
    <ContourPlot lossFunc={loss} logScale={false} opacity={i==selected_task ? 1 : 0} />
    {/each}

    {#each tasks as loss, i}
    <ContourPlot lossFunc={loss} logScale={false} opacity={i==selected_task ? 1 : 0} />
    {/each}

    {#each updates as phi, i}
    <Arrow origin={theta} target={phi} trimStart=0 trimEnd=0.01 stroke="#fff" fill="#fff" stroke-width="2" />
    {/each}

    <VariableHandleWithReference bind:position={theta} value="\theta" offset={[0, -15]} referencePoint={null} />

    {#each updates as phi, i}
    <VariableHandleWithReference bind:position={phi} value={`\\phi_{${i}}`} offset={[0, -15]} referencePoint={theta} />
    {/each}

    {#each algos as alg, i}
    <Arrow origin={theta} target={alg} trimStart=0 trimEnd=0.01 stroke="#fff" fill="#fff" stroke-width="2" />
    {/each}

    {#each algos as alg, i}
    <VariableHandleWithReference position={alg} value={`A_{${i}}`} offset={[0, -15]} referencePoint={theta}
      withPoint="{false}" />
    {/each}

  </Axis>
</Chart>



<script>
  import ContourPlot from './contourPlot.html'
  import { Chart, Axis, Arrow, VariableHandleWithReference } from './elements'
  import * as d3 from 'd3';
  import { onMount, getContext } from 'svelte';
  import * as tf from '@tensorflow/tfjs'
  import { Random2DLinearRegressionLossSpace } from './util/LossSpace'

  import { rosenbrock as loss_1 } from './util/loss'
  import { beale as loss_2 } from './util/loss'

  import { MetaVariable, Reptile, FirstOrderMAML } from './util/metal-lib'

  // Credit: https://stackoverflow.com/questions/27078285/simple-throttle-in-js
  function throttle(callback, limit) {
    var waiting = false;                      // Initially, we're not waiting
    return function () {                      // We return a throttled function
      if (!waiting) {                       // If we're not waiting
        callback.apply(this, arguments);  // Execute users function
        waiting = true;                   // Prevent future invocations
        setTimeout(function () {          // After a period of time
          waiting = false;              // And allow future invocations
        }, limit);
      }
    }
  }

  let theta = [0.5, .9]
  let means = [[0, 0], [1, 0]]
  let lossSpaces = means.map(mean => new Random2DLinearRegressionLossSpace(mean))

  let lr = 0.03

  let metaLoss = x => tf.stack(lossSpaces.map(space => {
    let upd = space.paramUpdate(x, lr, false)
    return space.loss(upd)
  })).sum(0)

  let tasks = [metaLoss, ...lossSpaces.map(space => space.loss)]

  const U = (space, t) => space.toArray(space.paramUpdate([t], lr, true))
  const add2d = (a, b) => [a[0] + b[0], a[1] + b[1]]
  const sub2d = (a, b) => [a[0] - b[0], a[1] - b[1]]
  const mul2d = (a, b) => [a * b[0], a * b[1]]

  let updates = lossSpaces.map(space => U(space, theta))

  let selected_task = 0
  let beta = 0.03
  let eta = 0.5

  let algos = [theta, theta]

  let lossGradients = lossSpaces.map(space => space.lossGrad)
  let reptile = new Reptile(eta, lr, 5)

  let fomaml = new FirstOrderMAML(beta)

  function updateReptile(t){
    let thetaVar = new MetaVariable([t])
    algos[0] = thetaVar.transform(reptile)(lossGradients).toArray()
  }

  function updateFomaml(t){
    let thetaVar = new MetaVariable([t])
    algos[1] = thetaVar.transform(fomaml)(lossGradients, updates).toArray()
  }

  const updateReptileThrottle = throttle(updateReptile, 100)
  const updateFomamlThrottle = throttle(updateFomaml, 100)

  $: {
    updateFomamlThrottle(theta)
  }

  $: {
    updateReptileThrottle(theta)
  }

</script>