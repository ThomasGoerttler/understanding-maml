{#each [0,'controls',2] as row}
  <div class="columns">
    {#if row != 'controls'}
      {#each [row,row+1] as i}
        <div class="column is-half">
          <Chart width=300 height=300>
            <Axis>
              <DynamicContourPlot loss={loss_functions[i]} logScale={false} />
              <VariableHandle bind:position={theta} value="\theta" withPoint={false} onDragEnd={recalculate} onDrag={recalculateSlow} />
              <Translate position={phis[i]}>
                <Latex value="\phi" style="font-size: 0.8em; color:white" />
              </Translate>
          </Axis>
          </Chart>
        </div>
      {/each}
    {:else}
      <div class="column is-half">
        <Slider min="0" max="5" bind:value={lambda_slider} id="imaml_lambda" label={`Learning Rate: ${lambda.toPrecision(2)}`} />
      </div>
    {/if}
  </div>
{/each}

<style>
  .column {
    text-align: center;
  }
</style>


<script>
  import * as d3 from 'd3';
  import { onMount } from 'svelte';
  import * as tf from '@tensorflow/tfjs'


  import range from 'lodash/range'
  import throttle from 'lodash/throttle'


  import {RBFLoss} from './util/loss';

  import {Slider, Chart, Axis, VariableHandle, Arrow, Translate, Latex} from './elements'
  import DynamicContourPlot from './dynamicContourPlot.html'


  export let theta = [0.5, 0.5]

  let lambda, lambda_slider = 1

  let lr = 0.1
  let steps = 5
  let optimizer = tf.train.sgd(lr)

  lambda = 1

  /*$: {
    lambda = 1 -
  }*/

  const loss_1 = phi => RBFLoss(phi,
    tf.tensor([[0.5, 0.7], [0.4, 0.2], [0.6, 0.2], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_2 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.8], [0.2, 0.3], [0.7, 0.1], [0.8, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_3 = phi => RBFLoss(phi,
    tf.tensor([[0.4, 0.7], [0.3, 0.2], [0.8, 0.1], [1.0, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_4 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.7], [0.4, 0.2], [0.2, -0.1], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));


  let original_loss_functions = [
    loss_1, loss_2, loss_3, loss_4
  ];

  const regularizer = (theta, grid, lambda=1) => {
    return grid.squaredDifference(theta).sum(-1).mul(lambda)
  }


  const regularizedLosses = (theta) => {
    let id = theta[0] + ', ' + theta[1];
    return original_loss_functions.map((loss) => ({
      id: id,
        func: (x) => (
        loss(x).add(
          regularizer(theta, x, lambda)
        )
      )
    }))
  }


  let loss_functions = regularizedLosses(theta)

  let phis = Array(loss_functions.length).fill(theta)


  onMount(() => {
    recalculate()
  })

  const recalculate = () => {
    loss_functions = regularizedLosses(theta)

    tf.tidy(() => {
      Promise.all(
        loss_functions.map(async (loss, i) => {
          let x = tf.variable(tf.tensor(theta))

          for (let i in range(steps)) {
            optimizer.minimize(() => loss.func(x).sum(), x)
          }

          return (await x.buffer()).values

        })
      ).then((x) => {
        phis = Array.from(x);
      })
    })
  }

  const recalculateSlow = throttle(recalculate, 300);
</script>
