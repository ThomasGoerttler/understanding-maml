<div class="columns">

  <div class="column is-half">
    <Partial loss={loss_functions[0]} trajectory={trajectories[0]} bind:theta={theta} {calculateTrajectories}/>
  </div>

  <div class="column is-half">
    <Partial loss={loss_functions[1]} trajectory={trajectories[1]} bind:theta={theta} {calculateTrajectories}/>
  </div>

</div>
<div class="columns">


  <div class="column is-half">
    <Slider min="-4" max="0" bind:value={lr_exp} id="userOptimizedTheta_lr" label={`Learning Rate: ${lr.toPrecision(2)}`} />
  </div>

  <div class="column is-half">
    <Slider min="1" max="5" bind:value={steps} id="userOptimizedTheta_steps" label={`Inner optimization steps: ${steps}`} />
  </div>

</div>
<div class="columns">

  <div class="column is-half">
    <Partial loss={loss_functions[2]} trajectory={trajectories[2]} bind:theta={theta} {calculateTrajectories}/>
  </div>

  <div class="column is-half">
    <Partial loss={loss_functions[3]} trajectory={trajectories[3]} bind:theta={theta} {calculateTrajectories}/>
  </div>

</div>

<style>
  .column {
    text-align: center;
  }
</style>


<script>
  import * as d3 from 'd3';
  import { onMount } from 'svelte';
  import * as tf from '@tensorflow/tfjs'


  import range from 'lodash/range'


  import {RBFLoss} from './util/loss';

  import {Slider} from './elements'

  import Partial from './userOptimizedThetaPartial.html'


  export let theta = [0.5, 0.5]

  let lr_exp = -2
  let steps = 1
  let lr
  let optimizer

  $: {
    lr = Math.pow(10, lr_exp/2)
    optimizer = tf.train.sgd(lr)
    calculateTrajectories()
  }

  const loss_1 = phi => RBFLoss(phi,
    tf.tensor([[0.5, 0.7], [0.4, 0.2], [0.6, 0.2], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_2 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.8], [0.2, 0.3], [0.7, 0.1], [0.8, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_3 = phi => RBFLoss(phi,
    tf.tensor([[0.4, 0.7], [0.3, 0.2], [0.8, 0.1], [1.0, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_4 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.7], [0.4, 0.2], [0.2, -0.1], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));


  let loss_functions = [
    loss_1, loss_2, loss_3, loss_4
  ];



  let trajectories = Array(loss_functions.length).fill([{origin:theta, target: theta}])


  onMount(() => {
    calculateTrajectories()
  })

  const calculateTrajectories = () => {
    var t0 = performance.now()

    tf.tidy(() => {
      Promise.all(
        loss_functions.map((loss, i) => {
          let x = tf.variable(tf.tensor(theta))

          return Promise.all(range(steps).map((s) => {
            optimizer.minimize(() => loss(x).sum(), x)
            return x.buffer()
          }));
        })
      ).then((ts) => {

        trajectories = ts.map((t) => range(t.length).map((j) => ({
          origin: (j == 0 ? theta : Array.from(t[j-1].values)),
          target: Array.from(t[j].values)
        })))

        console.log((performance.now() - t0))
      })
    })
  }
</script>
