<div class="container">

  <div class="col">
    <Partial loss={loss_functions[0]} trajectory={trajectories[0]} bind:theta={theta} {calculateTrajectories}/>
  </div>

  <div class="col">
    <Partial loss={loss_functions[1]} trajectory={trajectories[1]} bind:theta={theta} {calculateTrajectories}/>
  </div>

  <div class="col">
    <div class="centered">
      <input type="range" min="-4" max="0" bind:value={lr_exp} class="slider" id="userOptimizedTheta_lr">
      <br>
      <label for="userOptimizedTheta_lr">
        Learning Rate: {lr}
      </label>
    </div>
  </div>


  <div class="col">
    <div class="centered">
      <input type="range" min="1" max="5" bind:value={steps} class="slider" id="userOptimizedTheta_steps" on:change={calculateTrajectories}>
      <br>
      <label for="userOptimizedTheta_steps">
        Inner optimization steps: {steps}
      </label>
    </div>
  </div>

  <div class="col">
    <Partial loss={loss_functions[2]} trajectory={trajectories[2]} bind:theta={theta} {calculateTrajectories}/>
  </div>

  <div class="col">
    <Partial loss={loss_functions[3]} trajectory={trajectories[3]} bind:theta={theta} {calculateTrajectories}/>
  </div>

</div>

<style>
  .container {
    display: flex;
    flex-flow: row;
    flex-wrap: wrap;
  }
  .container .col {
      text-align: center;
      min-width: 50%;

  }
  .container .col .centered {
        margin: 0 auto;
        display: inline-block;
  }

  label {
    font-size: .8em;
  }
</style>


<script>
  import * as d3 from 'd3';
  import { onMount } from 'svelte';
  import * as tf from '@tensorflow/tfjs'


  import range from 'lodash/range'


  import {RBFLoss} from './util/loss';

  import Partial from './userOptimizedThetaPartial.html'


  export let theta = [0.5, 0.5]

  let lr_exp = -2
  let steps = 1
  let lr
  let optimizer

  $: {
    lr = Math.pow(10, lr_exp/2)
    optimizer = tf.train.sgd(lr)
    calculateTrajectories()
  }

  const loss_1 = phi => RBFLoss(phi,
    tf.tensor([[0.5, 0.7], [0.4, 0.2], [0.6, 0.2], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_2 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.8], [0.2, 0.3], [0.7, 0.1], [0.8, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_3 = phi => RBFLoss(phi,
    tf.tensor([[0.4, 0.7], [0.3, 0.2], [0.8, 0.1], [1.0, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_4 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.7], [0.4, 0.2], [0.2, -0.1], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));


  let loss_functions = [
    loss_1, loss_2, loss_3, loss_4
  ];



  let trajectories = Array(loss_functions.length).fill([{origin:theta, target: theta}])


  onMount(() => {
    calculateTrajectories()
  })

  const calculateTrajectories = () => {
    var t0 = performance.now()

    tf.tidy(() => {
      Promise.all(
        loss_functions.map((loss, i) => {
          let x = tf.variable(tf.tensor(theta))

          return Promise.all(range(steps).map((s) => {
            optimizer.minimize(() => loss(x).sum(), x)
            return x.buffer()
          }));
        })
      ).then((ts) => {

        trajectories = ts.map((t) => range(t.length).map((j) => ({
          origin: (j == 0 ? theta : Array.from(t[j-1].values)),
          target: Array.from(t[j].values)
        })))

        console.log((performance.now() - t0))
      })
    })
  }
</script>
