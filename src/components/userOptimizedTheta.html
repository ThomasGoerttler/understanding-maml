<div class="container">
  {#each plots as plot}
    <div class="col">
      <Chart width=300 height=300>
        <Axis>
          <ContourPlot lossFunc={plot.loss} logScale={plot.logScale} />
          <VariableHandle bind:position={theta} value="\theta" withPoint={false} onDragEnd={caculateTrajectories} />
          {#each plot.trajectory as segment}
            <Arrow origin={segment.origin} target={segment.target} trimStart=0.1 trimEnd=0.1
                  stroke="#fff" fill="#fff" stroke-width="1" />
          {/each}
          {#if plot.phi}
            <Translate position={plot.phi}>
              <Latex value="\phi" style="font-size: 0.8em; color:white" />
            </Translate>
          {/if}
      </Axis>
      </Chart>
    </div>
	{/each}

  <div class="col">
    <div class="centered">
      <input type="range" min="-4" max="0" bind:value={lr_exp} class="slider" id="userOptimizedTheta_lr">
      <br>
      <label for="userOptimizedTheta_lr">
        Learning Rate: {lr}
      </label>
    </div>
  </div>


  <div class="col">
    <div class="centered">
      <input type="range" min="1" max="10" bind:value={steps} class="slider" id="userOptimizedTheta_steps" on:change={caculateTrajectories}>
      <br>
      <label for="userOptimizedTheta_steps">
        Inner optimization steps: {steps}
      </label>
    </div>
  </div>
</div>

<style>
  .container {
    display: flex;
    flex-flow: row;
    flex-wrap: wrap;
  }
  .container .col {
      text-align: center;
      min-width: 50%;

  }
  .container .col .centered {
        margin: 0 auto;
        display: inline-block;
  }

  label {
    font-size: .8em;
  }
</style>


<script>
  import * as d3 from 'd3';
  import { onMount } from 'svelte';
  import * as tf from '@tensorflow/tfjs'


  import {RBFLoss} from './util/loss';

  import {Chart, Axis, VariableHandle, Arrow, Translate, Latex} from './elements'

  import ContourPlot from './contourPlot.html'


  export let theta = [0.5, 0.5]

  let lr_exp = -2
  let steps = 1
  let lr
  let optimizer

  $: {
    lr = Math.pow(10, lr_exp/2)
    optimizer = tf.train.sgd(lr)
    caculateTrajectories()
  }

  const loss_1 = phi => RBFLoss(phi,
    tf.tensor([[0.5, 0.7], [0.4, 0.2], [0.6, 0.2], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_2 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.8], [0.2, 0.3], [0.7, 0.1], [0.8, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_3 = phi => RBFLoss(phi,
    tf.tensor([[0.4, 0.7], [0.3, 0.2], [0.8, 0.1], [1.0, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_4 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.7], [0.4, 0.2], [0.2, -0.1], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));


  let plots = [
    {loss: loss_1, logScale: false, trajectory: [], phi: null},
    {loss: loss_2, logScale: false, trajectory: [], phi: null},
    {loss: loss_3, logScale: false, trajectory: [], phi: null},
    {loss: loss_4, logScale: false, trajectory: [], phi: null},
  ]

  onMount(() => {
    caculateTrajectories()
  })


  function caculateTrajectories() {
    let newPlots = [];

    plots.forEach((plot, i) => {
      tf.tidy(() => {
        let x = tf.variable(tf.tensor(theta))
        let trajectory = []
        let last = theta, current

        for (var s = 0; s < steps; s++) {
          optimizer.minimize(() => plot.loss(x).sum(), x)

          current = Array.from(x.bufferSync().values)

          trajectory.push({
            origin: last,
            target: current
          })

          last = current

        }
        plot.trajectory = trajectory
        plot.phi = last
        newPlots.push(plot)
      })
    })
    plots = newPlots
  }





</script>
