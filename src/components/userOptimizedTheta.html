{#each [0,'controls',2] as row}
  <div class="columns">
    {#if row != 'controls'}
      {#each [row,row+1] as i}
        <div class="column is-half">
          <Chart width=300 height=300>
            <Axis>
              <DynamicContourPlot loss={loss_functions[i]} logScale={false} />
              <VariableHandle bind:position={theta} value="\theta" withPoint={false} onDragEnd={recalculate} onDrag={recalculateSlow} />
              {#each trajectories[i] as segment}
                <Arrow origin={segment.origin} target={segment.target} trimStart=0.1 trimEnd=0.1
                      stroke="#fff" fill="#fff" stroke-width="1" />
              {/each}
              <Translate position={trajectories[i][trajectories[i].length-1].target}>
                <Latex value="\phi" style="font-size: 0.8em; color:white" />
              </Translate>
          </Axis>
          </Chart>
        </div>
      {/each}
    {:else}
      <div class="column is-half">
        <Slider min="-4" max="0" bind:value={lr_exp} id="userOptimizedTheta_lr" label={`Learning Rate: ${lr.toPrecision(2)}`} />
      </div>

      <div class="column is-half">
        <Slider min="1" max="5" bind:value={steps} id="userOptimizedTheta_steps" label={`Inner optimization steps: ${steps}`} />
      </div>
    {/if}
  </div>
{/each}


<style>
  .column {
    text-align: center;
  }
</style>


<script>
  import * as d3 from 'd3';
  import { onMount } from 'svelte';
  import * as tf from '@tensorflow/tfjs'


  import range from 'lodash/range'
  import throttle from 'lodash/throttle'


  import {RBFLoss} from './util/loss';

  import {Slider, Chart, Axis, VariableHandle, Arrow, Translate, Latex} from './elements'
  import DynamicContourPlot from './dynamicContourPlot.html'


  export let theta = [0.5, 0.5]

  let lr_exp = -2
  let steps = 1
  let lr
  let optimizer

  $: {
    lr = Math.pow(10, lr_exp/2)
    //mark dirty
    steps=steps
    optimizer = tf.train.sgd(lr)
    recalculate()
  }

  const loss_1 = phi => RBFLoss(phi,
    tf.tensor([[0.5, 0.7], [0.4, 0.2], [0.6, 0.2], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_2 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.8], [0.2, 0.3], [0.7, 0.1], [0.8, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_3 = phi => RBFLoss(phi,
    tf.tensor([[0.4, 0.7], [0.3, 0.2], [0.8, 0.1], [1.0, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));

  const loss_4 = phi => RBFLoss(phi,
    tf.tensor([[0.6, 0.7], [0.4, 0.2], [0.2, -0.1], [0.9, 0.3]]),
    tf.tensor([-1, -1.5, 2, -1.5]));


  let loss_functions = ([
    loss_1, loss_2, loss_3, loss_4
  ]).map((loss) => ({id: 0, func: loss}));



  let trajectories = Array(loss_functions.length).fill([{origin:theta, target: theta}])


  onMount(() => {
    recalculate()
  })

  const recalculate = () => {

    tf.tidy(() => {
      Promise.all(
        loss_functions.map((loss, i) => {
          let x = tf.variable(tf.tensor(theta))

          return Promise.all(range(steps).map((s) => {
            optimizer.minimize(() => loss.func(x).sum(), x)
            return x.buffer()
          }));
        })
      ).then((ts) => {

        trajectories = ts.map((t) => range(t.length).map((j) => ({
          origin: (j == 0 ? theta : Array.from(t[j-1].values)),
          target: Array.from(t[j].values)
        })))

      })
    })
  }

  const recalculateSlow = throttle(recalculate, 120);
</script>
